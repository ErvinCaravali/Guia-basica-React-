{"ast":null,"code":"import Panel from \"./panel.js\";\nconst _Stats = class _Stats2 {\n  constructor({\n    logsPerSecond = 20,\n    samplesLog = 100,\n    samplesGraph = 10,\n    precision = 2,\n    minimal = false,\n    horizontal = true,\n    mode = 0\n  } = {}) {\n    this.totalCpuDuration = 0;\n    this.totalGpuDuration = 0;\n    this.totalGpuDurationCompute = 0;\n    this.totalFps = 0;\n    this.activeQuery = null;\n    this.gpuQueries = [];\n    this.renderCount = 0;\n    this.mode = mode;\n    this.horizontal = horizontal;\n    this.dom = document.createElement(\"div\");\n    this.dom.style.cssText = \"position:fixed;top:0;left:0;opacity:0.9;z-index:10000;\";\n    if (minimal) {\n      this.dom.style.cssText += \"cursor:pointer\";\n    }\n    this.gl = null;\n    this.query = null;\n    this.isRunningCPUProfiling = false;\n    this.minimal = minimal;\n    this.beginTime = (performance || Date).now();\n    this.prevTime = this.beginTime;\n    this.prevCpuTime = this.beginTime;\n    this.frames = 0;\n    this.renderCount = 0;\n    this.threeRendererPatched = false;\n    this.averageCpu = {\n      logs: [],\n      graph: []\n    };\n    this.averageGpu = {\n      logs: [],\n      graph: []\n    };\n    this.averageGpuCompute = {\n      logs: [],\n      graph: []\n    };\n    this.queryCreated = false;\n    this.fpsPanel = this.addPanel(new _Stats2.Panel(\"FPS\", \"#0ff\", \"#002\"), 0);\n    this.msPanel = this.addPanel(new _Stats2.Panel(\"CPU\", \"#0f0\", \"#020\"), 1);\n    this.gpuPanel = null;\n    this.gpuPanelCompute = null;\n    this.samplesLog = samplesLog;\n    this.samplesGraph = samplesGraph;\n    this.precision = precision;\n    this.logsPerSecond = logsPerSecond;\n    if (this.minimal) {\n      this.dom.addEventListener(\"click\", event => {\n        event.preventDefault();\n        this.showPanel(++this.mode % this.dom.children.length);\n      }, false);\n      this.mode = mode;\n      this.showPanel(this.mode);\n    } else {\n      window.addEventListener(\"resize\", () => {\n        this.resizePanel(this.fpsPanel, 0);\n        this.resizePanel(this.msPanel, 1);\n        if (this.gpuPanel) {\n          this.resizePanel(this.gpuPanel, 2);\n        }\n        if (this.gpuPanelCompute) {\n          this.resizePanel(this.gpuPanelCompute, 3);\n        }\n      });\n    }\n  }\n  patchThreeRenderer(renderer) {\n    const originalRenderMethod = renderer.render;\n    const statsInstance = this;\n    renderer.render = function (scene, camera) {\n      if (statsInstance.info !== void 0) {\n        statsInstance.totalGpuDuration = this.info.timestamp.render;\n        statsInstance.totalGpuDurationCompute = this.info.timestamp.compute;\n      }\n      statsInstance.begin();\n      originalRenderMethod.call(this, scene, camera);\n      statsInstance.end();\n    };\n    if (renderer.renderAsync) {\n      const originalRenderAsyncMethod = renderer.renderAsync;\n      renderer.renderAsync = function (scene, camera) {\n        if (statsInstance.info !== void 0) {\n          statsInstance.totalGpuDuration = this.info.timestamp.render;\n          statsInstance.totalGpuDurationCompute = this.info.timestamp.compute;\n        }\n        statsInstance.begin();\n        originalRenderAsyncMethod.call(this, scene, camera);\n        statsInstance.end();\n      };\n    }\n    this.threeRendererPatched = true;\n  }\n  resizePanel(panel, offset) {\n    panel.canvas.style.position = \"absolute\";\n    if (this.minimal) {\n      panel.canvas.style.display = \"none\";\n    } else {\n      panel.canvas.style.display = \"block\";\n      if (this.horizontal) {\n        panel.canvas.style.top = \"0px\";\n        panel.canvas.style.left = offset * panel.WIDTH / panel.PR + \"px\";\n      } else {\n        panel.canvas.style.left = \"0px\";\n        panel.canvas.style.top = offset * panel.HEIGHT / panel.PR + \"px\";\n      }\n    }\n  }\n  addPanel(panel, offset) {\n    if (panel.canvas) {\n      this.dom.appendChild(panel.canvas);\n      this.resizePanel(panel, offset);\n    }\n    return panel;\n  }\n  showPanel(id) {\n    for (let i = 0; i < this.dom.children.length; i++) {\n      const child = this.dom.children[i];\n      child.style.display = i === id ? \"block\" : \"none\";\n    }\n    this.mode = id;\n  }\n  async init(canvasOrGL) {\n    if (!canvasOrGL) {\n      console.error('Stats: The \"canvas\" parameter is undefined.');\n      return;\n    }\n    if ((canvasOrGL.isWebGLRenderer || canvasOrGL.isWebGPURenderer) && !this.threeRendererPatched) {\n      const canvas = canvasOrGL;\n      this.patchThreeRenderer(canvas);\n      this.gl = canvas.getContext();\n    } else if (!this.gl && canvasOrGL instanceof WebGL2RenderingContext) {\n      this.gl = canvasOrGL;\n    }\n    if (canvasOrGL.isWebGPURenderer) {\n      canvasOrGL.backend.trackTimestamp = true;\n      if (await canvasOrGL.hasFeatureAsync(\"timestamp-query\")) {\n        this.gpuPanel = this.addPanel(new _Stats2.Panel(\"GPU\", \"#ff0\", \"#220\"), 2);\n        this.gpuPanelCompute = this.addPanel(new _Stats2.Panel(\"COM\", \"#e1e1e1\", \"#212121\"), 3);\n        this.info = canvasOrGL.info;\n      }\n      return;\n    } else if (!this.gl && canvasOrGL instanceof HTMLCanvasElement || canvasOrGL instanceof OffscreenCanvas) {\n      this.gl = canvasOrGL.getContext(\"webgl2\");\n      if (!this.gl) {\n        console.error(\"Stats: Unable to obtain WebGL2 context.\");\n        return;\n      }\n    } else if (!this.gl) {\n      console.error(\"Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas.\");\n      return;\n    }\n    this.ext = this.gl.getExtension(\"EXT_disjoint_timer_query_webgl2\");\n    if (this.ext) {\n      this.gpuPanel = this.addPanel(new _Stats2.Panel(\"GPU\", \"#ff0\", \"#220\"), 2);\n    }\n  }\n  begin() {\n    if (!this.isRunningCPUProfiling) {\n      this.beginProfiling(\"cpu-started\");\n    }\n    if (!this.gl || !this.ext) return;\n    if (this.gl && this.ext) {\n      if (this.activeQuery) {\n        this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);\n      }\n      this.activeQuery = this.gl.createQuery();\n      if (this.activeQuery !== null) {\n        this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.activeQuery);\n      }\n    }\n  }\n  end() {\n    this.renderCount++;\n    if (this.gl && this.ext && this.activeQuery) {\n      this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);\n      this.gpuQueries.push({\n        query: this.activeQuery\n      });\n      this.activeQuery = null;\n    }\n  }\n  processGpuQueries() {\n    if (!this.gl || !this.ext) return;\n    this.totalGpuDuration = 0;\n    this.gpuQueries.forEach((queryInfo, index) => {\n      if (this.gl) {\n        const available = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE);\n        const disjoint = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);\n        if (available && !disjoint) {\n          const elapsed = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT);\n          const duration = elapsed * 1e-6;\n          this.totalGpuDuration += duration;\n          this.gl.deleteQuery(queryInfo.query);\n          this.gpuQueries.splice(index, 1);\n        }\n      }\n    });\n  }\n  update() {\n    this.processGpuQueries();\n    this.endProfiling(\"cpu-started\", \"cpu-finished\", \"cpu-duration\");\n    this.addToAverage(this.totalCpuDuration, this.averageCpu);\n    this.addToAverage(this.totalGpuDuration, this.averageGpu);\n    this.renderCount = 0;\n    this.totalCpuDuration = 0;\n    if (this.info !== void 0) {\n      this.addToAverage(this.totalGpuDurationCompute, this.averageGpuCompute);\n      this.totalGpuDuration = 0;\n      this.totalGpuDurationCompute = 0;\n    }\n    this.totalFps = 0;\n    this.beginTime = this.endInternal();\n  }\n  endInternal() {\n    this.frames++;\n    const time = (performance || Date).now();\n    if (time >= this.prevCpuTime + 1e3 / this.logsPerSecond) {\n      this.updatePanel(this.msPanel, this.averageCpu);\n      this.updatePanel(this.gpuPanel, this.averageGpu);\n      if (this.gpuPanelCompute) {\n        this.updatePanel(this.gpuPanelCompute, this.averageGpuCompute);\n      }\n      this.prevCpuTime = time;\n    }\n    if (time >= this.prevTime + 1e3) {\n      const fps = this.frames * 1e3 / (time - this.prevTime);\n      this.fpsPanel.update(fps, fps, 100, 100, 0);\n      this.prevTime = time;\n      this.frames = 0;\n    }\n    return time;\n  }\n  addToAverage(value, averageArray) {\n    averageArray.logs.push(value);\n    if (averageArray.logs.length > this.samplesLog) {\n      averageArray.logs.shift();\n    }\n    averageArray.graph.push(value);\n    if (averageArray.graph.length > this.samplesGraph) {\n      averageArray.graph.shift();\n    }\n  }\n  beginProfiling(marker) {\n    if (window.performance) {\n      window.performance.mark(marker);\n      this.isRunningCPUProfiling = true;\n    }\n  }\n  endProfiling(startMarker, endMarker, measureName) {\n    if (window.performance && endMarker && this.isRunningCPUProfiling) {\n      window.performance.mark(endMarker);\n      const cpuMeasure = performance.measure(measureName, startMarker, endMarker);\n      this.totalCpuDuration += cpuMeasure.duration;\n      this.isRunningCPUProfiling = false;\n    }\n  }\n  updatePanel(panel, averageArray) {\n    if (averageArray.logs.length > 0) {\n      let sumLog = 0;\n      let max = 0.01;\n      for (let i = 0; i < averageArray.logs.length; i++) {\n        sumLog += averageArray.logs[i];\n        if (averageArray.logs[i] > max) {\n          max = averageArray.logs[i];\n        }\n      }\n      let sumGraph = 0;\n      let maxGraph = 0.01;\n      for (let i = 0; i < averageArray.graph.length; i++) {\n        sumGraph += averageArray.graph[i];\n        if (averageArray.graph[i] > maxGraph) {\n          maxGraph = averageArray.graph[i];\n        }\n      }\n      if (panel) {\n        panel.update(sumLog / Math.min(averageArray.logs.length, this.samplesLog), sumGraph / Math.min(averageArray.graph.length, this.samplesGraph), max, maxGraph, this.precision);\n      }\n    }\n  }\n  get domElement() {\n    return this.dom;\n  }\n  get container() {\n    console.warn(\"Stats: Deprecated! this.container as been replaced to this.dom \");\n    return this.dom;\n  }\n};\n_Stats.Panel = Panel;\nlet Stats = _Stats;\nexport { Stats as default };","map":{"version":3,"names":["_Stats","_Stats2","constructor","logsPerSecond","samplesLog","samplesGraph","precision","minimal","horizontal","mode","totalCpuDuration","totalGpuDuration","totalGpuDurationCompute","totalFps","activeQuery","gpuQueries","renderCount","dom","document","createElement","style","cssText","gl","query","isRunningCPUProfiling","beginTime","performance","Date","now","prevTime","prevCpuTime","frames","threeRendererPatched","averageCpu","logs","graph","averageGpu","averageGpuCompute","queryCreated","fpsPanel","addPanel","Panel","msPanel","gpuPanel","gpuPanelCompute","addEventListener","event","preventDefault","showPanel","children","length","window","resizePanel","patchThreeRenderer","renderer","originalRenderMethod","render","statsInstance","scene","camera","info","timestamp","compute","begin","call","end","renderAsync","originalRenderAsyncMethod","panel","offset","canvas","position","display","top","left","WIDTH","PR","HEIGHT","appendChild","id","i","child","init","canvasOrGL","console","error","isWebGLRenderer","isWebGPURenderer","getContext","WebGL2RenderingContext","backend","trackTimestamp","hasFeatureAsync","HTMLCanvasElement","OffscreenCanvas","ext","getExtension","beginProfiling","endQuery","TIME_ELAPSED_EXT","createQuery","beginQuery","push","processGpuQueries","forEach","queryInfo","index","available","getQueryParameter","QUERY_RESULT_AVAILABLE","disjoint","getParameter","GPU_DISJOINT_EXT","elapsed","QUERY_RESULT","duration","deleteQuery","splice","update","endProfiling","addToAverage","endInternal","time","updatePanel","fps","value","averageArray","shift","marker","mark","startMarker","endMarker","measureName","cpuMeasure","measure","sumLog","max","sumGraph","maxGraph","Math","min","domElement","container","warn","Stats"],"sources":["/home/ervin/Escritorio/Guia-basica-React-/node_modules/stats-gl/lib/main.ts"],"sourcesContent":["import Panel from \"./panel\";\nimport * as THREE from 'three';\nexport interface AverageArray {\n  logs: number[];\n  graph: number[];\n}\n\n\nclass Stats {\n  totalCpuDuration: number = 0;\n  totalGpuDuration: number = 0;\n  totalGpuDurationCompute: number = 0;\n  totalFps: number = 0;\n  mode: number;\n  info: any;\n  dom: HTMLDivElement;\n  minimal: boolean;\n  horizontal: boolean;\n  beginTime: number;\n  prevTime: number;\n  prevCpuTime: number;\n  frames: number;\n  averageCpu: AverageArray;\n  averageGpu: AverageArray;\n  averageGpuCompute: AverageArray;\n  queryCreated: boolean;\n  isRunningCPUProfiling: boolean;\n  fpsPanel: Panel;\n  static Panel: typeof Panel = Panel;\n  msPanel: Panel;\n  gpuPanel: Panel | null;\n  gpuPanelCompute: Panel | null;\n  samplesLog: number;\n  samplesGraph: number;\n  logsPerSecond: number;\n  activeQuery: WebGLQuery | null = null;\n\n  precision: number;\n  gl: WebGL2RenderingContext | null;\n  ext: any;\n  query: WebGLQuery | null;\n  disjoint: any;\n  ns: any;\n  threeRendererPatched: boolean;\n  gpuQueries: { query: WebGLQuery }[] = [];\n  renderCount: number = 0;\n\n  constructor({ logsPerSecond = 20, samplesLog = 100, samplesGraph = 10, precision = 2, minimal = false, horizontal = true, mode = 0 } = {}) {\n\n    this.mode = mode;\n    this.horizontal = horizontal;\n    this.dom = document.createElement('div');\n    this.dom.style.cssText = 'position:fixed;top:0;left:0;opacity:0.9;z-index:10000;';\n\n    if (minimal) {\n\n      this.dom.style.cssText += 'cursor:pointer';\n\n    }\n\n    this.gl = null;\n    this.query = null;\n\n    this.isRunningCPUProfiling = false;\n    this.minimal = minimal;\n\n    this.beginTime = (performance || Date).now();\n    this.prevTime = this.beginTime;\n    this.prevCpuTime = this.beginTime;\n    this.frames = 0;\n    this.renderCount = 0;\n    this.threeRendererPatched = false;\n    this.averageCpu = {\n      logs: [],\n      graph: []\n    };\n    this.averageGpu = {\n      logs: [],\n      graph: []\n    };\n    this.averageGpuCompute = {\n      logs: [],\n      graph: []\n    };\n\n    this.queryCreated = false;\n\n    this.fpsPanel = this.addPanel(new Stats.Panel('FPS', '#0ff', '#002'), 0);\n    this.msPanel = this.addPanel(new Stats.Panel('CPU', '#0f0', '#020'), 1);\n    this.gpuPanel = null;\n    this.gpuPanelCompute = null;\n\n    this.samplesLog = samplesLog;\n    this.samplesGraph = samplesGraph;\n    this.precision = precision;\n    this.logsPerSecond = logsPerSecond;\n\n    if (this.minimal) {\n\n      this.dom.addEventListener('click', (event) => {\n\n        event.preventDefault();\n        this.showPanel(++this.mode % this.dom.children.length);\n\n      }, false);\n\n      this.mode = mode;\n      this.showPanel(this.mode);\n\n    } else {\n\n      window.addEventListener('resize', () => {\n\n        this.resizePanel(this.fpsPanel, 0);\n        this.resizePanel(this.msPanel, 1);\n\n        if (this.gpuPanel) {\n          this.resizePanel(this.gpuPanel, 2);\n        }\n        if (this.gpuPanelCompute) {\n          this.resizePanel(this.gpuPanelCompute, 3);\n        }\n      })\n    }\n\n\n  }\n\n  patchThreeRenderer(renderer: any) {\n\n    // Store the original render method\n    const originalRenderMethod = renderer.render;\n\n    // Reference to the stats instance\n    const statsInstance = this;\n\n    // Override the render method on the prototype\n    renderer.render = function (scene: THREE.Scene, camera: THREE.Camera) {\n\n\n      if (statsInstance.info !== undefined) {\n        statsInstance.totalGpuDuration = this.info.timestamp.render\n        statsInstance.totalGpuDurationCompute = this.info.timestamp.compute\n      }\n\n      statsInstance.begin(); // Start tracking for this render call\n\n      // Call the original render method\n      originalRenderMethod.call(this, scene, camera);\n\n      statsInstance.end(); // End tracking for this render call\n    };\n\n    if (renderer.renderAsync) {\n      const originalRenderAsyncMethod = renderer.renderAsync;\n\n      renderer.renderAsync = function (scene: THREE.Scene, camera: THREE.Camera) {\n\n        if (statsInstance.info !== undefined) {\n          statsInstance.totalGpuDuration = this.info.timestamp.render\n          statsInstance.totalGpuDurationCompute = this.info.timestamp.compute\n        }\n\n        statsInstance.begin(); // Start tracking for this render call\n\n        // Call the original render method\n        originalRenderAsyncMethod.call(this, scene, camera);\n\n        statsInstance.end(); // End tracking for this render call\n\n\n\n\n      };\n    }\n\n    this.threeRendererPatched = true;\n\n  }\n\n  resizePanel(panel: Panel, offset: number) {\n\n    panel.canvas.style.position = 'absolute';\n\n    if (this.minimal) {\n\n      panel.canvas.style.display = 'none';\n\n    } else {\n\n      panel.canvas.style.display = 'block';\n      if (this.horizontal) {\n        panel.canvas.style.top = '0px';\n        panel.canvas.style.left = offset * panel.WIDTH / panel.PR + 'px';\n      } else {\n        panel.canvas.style.left = '0px';\n        panel.canvas.style.top = offset * panel.HEIGHT / panel.PR + 'px';\n\n      }\n    }\n  }\n\n  addPanel(panel: Panel, offset: number) {\n\n    if (panel.canvas) {\n\n      this.dom.appendChild(panel.canvas);\n\n      this.resizePanel(panel, offset);\n\n    }\n\n    return panel;\n\n  }\n\n  showPanel(id: number) {\n\n    for (let i = 0; i < this.dom.children.length; i++) {\n      const child = this.dom.children[i] as HTMLElement;\n\n      child.style.display = i === id ? 'block' : 'none';\n\n    }\n\n    this.mode = id;\n\n  }\n\n  async init(canvasOrGL: any) {\n    if (!canvasOrGL) {\n      console.error('Stats: The \"canvas\" parameter is undefined.');\n      return;\n    }\n\n\n    // if ((canvasOrGL as any).isWebGPURenderer && !this.threeRendererPatched) {\n    // TODO Color GPU Analytic in another color than yellow to know webgpu or webgl context (blue)\n    //   const canvas: any = canvasOrGL\n    //   this.patchThreeRenderer(canvas as any);\n    //   this.gl = canvas.getContext();\n    // } else \n    if (((canvasOrGL as any).isWebGLRenderer || (canvasOrGL as any).isWebGPURenderer) && !this.threeRendererPatched) {\n      const canvas: any = canvasOrGL\n      this.patchThreeRenderer(canvas as any);\n      this.gl = canvas.getContext();\n    } else if (!this.gl && canvasOrGL instanceof WebGL2RenderingContext) {\n      this.gl = canvasOrGL;\n    }\n\n    if (canvasOrGL.isWebGPURenderer) {\n\n      canvasOrGL.backend.trackTimestamp = true\n\n      if (await canvasOrGL.hasFeatureAsync('timestamp-query')) {\n        this.gpuPanel = this.addPanel(new Stats.Panel('GPU', '#ff0', '#220'), 2);\n        this.gpuPanelCompute = this.addPanel(new Stats.Panel('COM', '#e1e1e1', '#212121'), 3);\n        this.info = canvasOrGL.info\n      }\n      return;\n    }\n    // Check if canvasOrGL is already a WebGL2RenderingContext\n\n\n    // Handle HTMLCanvasElement and OffscreenCanvas\n    else if (!this.gl && canvasOrGL instanceof HTMLCanvasElement || canvasOrGL instanceof OffscreenCanvas) {\n      this.gl = canvasOrGL.getContext('webgl2') as WebGL2RenderingContext;\n      if (!this.gl) {\n        console.error('Stats: Unable to obtain WebGL2 context.');\n        return;\n      }\n    } else if (!this.gl) {\n      console.error('Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas.');\n      return;\n    }\n\n    // Get the extension\n    this.ext = this.gl.getExtension('EXT_disjoint_timer_query_webgl2');\n    if (this.ext) {\n      this.gpuPanel = this.addPanel(new Stats.Panel('GPU', '#ff0', '#220'), 2);\n    }\n  }\n\n\n  begin() {\n\n    if (!this.isRunningCPUProfiling) {\n      this.beginProfiling('cpu-started');\n    }\n\n    if (!this.gl || !this.ext) return;\n\n    if (this.gl && this.ext) {\n      if (this.activeQuery) {\n        // End the previous query if it's still active\n        this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);\n      }\n\n      this.activeQuery = this.gl.createQuery();\n      if (this.activeQuery !== null) {\n        this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.activeQuery);\n      }\n    }\n  }\n\n\n\n  end() {\n\n    // Increase render count\n    this.renderCount++;\n\n    if (this.gl && this.ext && this.activeQuery) {\n      this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);\n      // Add the active query to the gpuQueries array and reset it\n      this.gpuQueries.push({ query: this.activeQuery });\n      this.activeQuery = null;\n    }\n\n  }\n\n  processGpuQueries() {\n\n\n    if (!this.gl || !this.ext) return;\n\n    this.totalGpuDuration = 0;\n\n    this.gpuQueries.forEach((queryInfo, index) => {\n      if (this.gl) {\n        const available = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE);\n        const disjoint = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);\n\n        if (available && !disjoint) {\n          const elapsed = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT);\n          const duration = elapsed * 1e-6;  // Convert nanoseconds to milliseconds\n          this.totalGpuDuration += duration;\n          this.gl.deleteQuery(queryInfo.query);\n          this.gpuQueries.splice(index, 1);  // Remove the processed query\n        }\n      }\n    });\n\n  }\n\n  update() {\n\n    this.processGpuQueries();\n    this.endProfiling('cpu-started', 'cpu-finished', 'cpu-duration');\n\n    // Calculate the total duration of CPU and GPU work for this frame\n    this.addToAverage(this.totalCpuDuration, this.averageCpu);\n    this.addToAverage(this.totalGpuDuration, this.averageGpu);\n\n    this.renderCount = 0;\n    this.totalCpuDuration = 0;\n\n    if (this.info !== undefined) {\n      this.addToAverage(this.totalGpuDurationCompute, this.averageGpuCompute);\n\n      this.totalGpuDuration = 0;\n      this.totalGpuDurationCompute = 0;\n\n    }\n    this.totalFps = 0;\n\n    this.beginTime = this.endInternal()\n\n\n\n  }\n\n  endInternal() {\n\n    this.frames++;\n    const time = (performance || Date).now();\n\n    if (time >= this.prevCpuTime + 1000 / this.logsPerSecond) {\n      this.updatePanel(this.msPanel, this.averageCpu);\n      this.updatePanel(this.gpuPanel, this.averageGpu);\n\n      if (this.gpuPanelCompute) {\n        this.updatePanel(this.gpuPanelCompute, this.averageGpuCompute);\n      }\n\n      this.prevCpuTime = time;\n    }\n\n    if (time >= this.prevTime + 1000) {\n\n      const fps = (this.frames * 1000) / (time - this.prevTime);\n\n      this.fpsPanel.update(fps, fps, 100, 100, 0);\n\n      this.prevTime = time;\n      this.frames = 0;\n\n    }\n\n    return time;\n\n  }\n\n  addToAverage(value: number, averageArray: { logs: any; graph: any; }) {\n\n    averageArray.logs.push(value);\n    if (averageArray.logs.length > this.samplesLog) {\n\n      averageArray.logs.shift();\n\n    }\n\n    averageArray.graph.push(value);\n    if (averageArray.graph.length > this.samplesGraph) {\n\n      averageArray.graph.shift();\n\n    }\n\n  }\n\n  beginProfiling(marker: string) {\n\n    if (window.performance) {\n\n      window.performance.mark(marker);\n      this.isRunningCPUProfiling = true\n\n    }\n\n  }\n\n  endProfiling(startMarker: string | PerformanceMeasureOptions | undefined, endMarker: string | undefined, measureName: string) {\n\n    if (window.performance && endMarker && this.isRunningCPUProfiling) {\n\n      window.performance.mark(endMarker);\n      const cpuMeasure = performance.measure(measureName, startMarker, endMarker);\n      this.totalCpuDuration += cpuMeasure.duration;\n      this.isRunningCPUProfiling = false\n\n    }\n\n  }\n\n  updatePanel(panel: { update: any; } | null, averageArray: { logs: number[], graph: number[] }) {\n\n    if (averageArray.logs.length > 0) {\n\n      let sumLog = 0;\n      let max = 0.01;\n\n      for (let i = 0; i < averageArray.logs.length; i++) {\n\n        sumLog += averageArray.logs[i];\n\n        if (averageArray.logs[i] > max) {\n          max = averageArray.logs[i];\n        }\n\n      }\n\n      let sumGraph = 0;\n      let maxGraph = 0.01;\n      for (let i = 0; i < averageArray.graph.length; i++) {\n\n        sumGraph += averageArray.graph[i];\n\n        if (averageArray.graph[i] > maxGraph) {\n          maxGraph = averageArray.graph[i];\n        }\n\n      }\n\n      if (panel) {\n        panel.update(sumLog / Math.min(averageArray.logs.length, this.samplesLog), sumGraph / Math.min(averageArray.graph.length, this.samplesGraph), max, maxGraph, this.precision);\n      }\n\n    }\n  }\n\n  get domElement() {\n    // patch for some use case in threejs\n    return this.dom;\n\n  }\n\n  get container() { // @deprecated\n\n    console.warn('Stats: Deprecated! this.container as been replaced to this.dom ')\n    return this.dom;\n\n  }\n\n}\n\n\nexport default Stats;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}